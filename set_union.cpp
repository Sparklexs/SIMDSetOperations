#include <cstdio>
#include <chrono>

#include "constants.h"
#include "shuffle_dictionary.hpp"

#include "union/naive.hpp"
#include "union/stl.hpp"
#include "union/branchless.hpp"
#include "union/sse.hpp"


void run(uint32_t **lists, size_t (*func)(const uint32_t*,size_t,const uint32_t*,size_t,uint32_t*)){
	uint32_t *union_list = (uint32_t*)aligned_alloc(32, 2*arraySize*sizeof(uint32_t));
	auto t_start = std::chrono::high_resolution_clock::now();
	size_t union_count=0;
	for(size_t i=0; i<listCount; ++i){
		for(size_t j=i+1; j<listCount; ++j){
			union_count += func(lists[i], arraySize, lists[j], arraySize, union_list);
		}
	}
	auto t_end = std::chrono::high_resolution_clock::now();
	printf("Wall clock time passed: %10.2f ms - %lu\n",
		std::chrono::duration<double, std::milli>(t_end-t_start).count(),
		union_count
	);
	free(union_list);
}

int main(){
#if 1
	auto t_start = std::chrono::high_resolution_clock::now();
	uint32_t **lists = new uint32_t*[listCount];
	// load lists from file which was generated by genLists
	FILE *fd = fopen("test.dat", "rb");
	if(!fd){
		puts("couldn't open test.dat");
		return -1;
	}
	for(size_t i=0; i<listCount; ++i){
		lists[i] = (uint32_t*)aligned_alloc(32, arraySize*sizeof(uint32_t));
		fread(lists[i], 4, arraySize, fd);
	}
	fclose(fd);
	auto t_end = std::chrono::high_resolution_clock::now(); 
	printf("preparing lists done - %f ms\n",
		std::chrono::duration<double, std::milli>(t_end-t_start).count()
	);

	puts("naive scalar union:");
	run(lists, union_scalar);
	puts("stl set_union:");
	run(lists, union_scalar_stl);
#if __GNUC__ >= 5
	puts("stl parallel set_union: uses more than one core, just for reference here");
	run(lists, union_scalar_stl_parallel);
#endif

	puts("asm branchless scalar union:");
	run(lists, union_scalar_branchless);

#ifdef __SSE2__
	prepare_shuffling_dictionary();
	puts("SSE union:");
	run(lists, union_vector_sse);
#endif


	// cleanup
	for(size_t i=0; i<listCount; ++i){
		free(lists[i]);
	}
	delete[] lists;
#else

#if 0
	const uint32_t list1[] = {
		 1,  3,  5,  7,  9, 11, 13, 15, 17, 19,
		21, 23, 25, 27, 29, 31, 33, 35, 37, 39
	};
	constexpr size_t list1Size = sizeof(list1)/sizeof(list1[0]);
	const uint32_t list2[] = {
		 2,  4,  6,  8, 10, 12, 14, 16, 18, 20,
		22, 24, 26, 28, 30, 32, 34, 36, 38, 40
	};
	constexpr size_t list2Size = sizeof(list2)/sizeof(list2[0]);
	uint32_t result[list1Size + list2Size];
#endif

	const unsigned int size = 23;
	uint32_t *list1 = (uint32_t*)aligned_alloc(32, size*sizeof(uint32_t));
	uint32_t *list2 = (uint32_t*)aligned_alloc(32, size*sizeof(uint32_t));
// 	for(unsigned int i=0; i<size; ++i){
// 		list1[i] = i*2;    // even
// 		list2[i] = i*2 /*+1*/; // odd
// 	}
	uint32_t *result = (uint32_t*)aligned_alloc(32, 2*size*sizeof(uint32_t));
	const size_t list1Size=size, list2Size=size;

// 	for(size_t r=0; r<100000; ++r){
		for(unsigned int i=0; i<size; ++i){
			list1[i] = i*2;    // even
			list2[i] = i*2 /*+1*/; // odd
		}

// 		size_t count = union_scalar_branchless(list1, list1Size, list2, list2Size, result);
		prepare_shuffling_dictionary();
// 		size_t count = union_sse(list1, list1Size, list2, list2Size, result);
// 		size_t count = union_sse_asm(list1, list1Size, list2, list2Size, result);
		size_t count = union_sse_asm2(list1, list1Size, list2, list2Size, result);
		for(size_t i=0; i<count; ++i){
			printf("%u\n", result[i]);
		}
// 	}
#endif


	return 0;
}
